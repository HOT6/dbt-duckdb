# dbt
  - https://docs.getdbt.com/docs/introduction
  > dbt is a transformation workflow : E**T**L
 <details>
<summary>

> dbt는 `sql`이나 `python`으로 작성된 데이터 변환을 관리하는 가장 좋은 방법

> core business logic을 반영하는 모델(i.e. `select queries`)을 작성하는데만 집중하면 된다. dbt가 구체화를 담당하기 때문에 boilerplate DML, DDL을 피할 수 있음

</summary>

> dbt is the best way to manage a collection of data transformations written in SQL or Python for analytics and data science.

> As a dbt user, your main focus will be on writing models (i.e. select queries) that reflect core business logic – there’s no need to write boilerplate code to create tables and views, or to define the order of execution of your models. Instead, dbt handles turning these models into objects in your warehouse for you.
</details>

## **The power of dbt**
|Feature|Description|
|------|---|
|Handle boilerplate code to materialize queries as relations|For each model you create, you can easily configure a materialization. A materialization represents a build strategy for your select query – the code behind a materialization is robust, boilerplate SQL that wraps your select query in a statement to create a new, or update an existing, relation. |
|Use a code compiler|SQL files can contain Jinja, a lightweight templating language. Using Jinja in SQL provides a way to use control structures in your queries. For example, if statements and for loops.|
|Determine the order of model execution|Often, when transforming data, it makes sense to do so in a staged approach. dbt provides a mechanism to implement transformations in stages through the ref function.|
|Document your dbt project|dbt provides a mechanism to write, version-control, and share documentation for your dbt models.|
|Test your models|Tests provide a way to improve the integrity of the SQL in each model by making assertions about the results generated by a model.|
|Manage packages|dbt ships with a package manager, which allows analysts to use and publish both public and private repositories of dbt code|
|Load seed files|data sources, known as seed files, can be saved as a CSV file in your project and loaded into your data warehouse using the seed command.|
|Snapshot data|dbt provides a mechanism to snapshot raw data for a point in time|


- 필요한 데이터의 select 문이나 python dataframe 로직을 제공하면 dbt가 구체화를 진행하므로 boilerplate code를 피할 수 있음.
- 쿼리 내에서 `if`, `for` 문 사용 가능
- `ref` 함수를 통해 단계적 변환 가능
- 문서 작성(`dbt docs generate` ?), 버전 컨트롤 가능
- 테스트(`dbt test`) 파일 작성으로 각 모델의 무결성 향상
- seed 데이터를 사용해(`dbt seed`) csv 파일을 읽어 데이터베이스에 적재 가능
- 특정 시점의 원시 데이터를 스냅샷하는 메커니즘 제공


## **dbt proejcts**
  > dbt enforces the top-level structure of a dbt project such as the `dbt_project.yml` file
  - Every dbt project includes a project configuration file called `dbt_project.yml`. It defines the directory of the dbt project and other project configurations.

|YAML key|Value description|
|--------|-----------------|
|name|Your project's name in `snake case`|
|version|Version of your project|
|require-dbt-version|Restrict your project to only work with a range of `dbt Core versions`|
|profile|The profile dbt uses to connect to your data platform|
|model-paths|Directories to where your model and source files live|
|seed-paths|Directories to where your seed files live|
|test-paths|Directories to where your test files live|
|analysis-paths|Directories to where your analyses live|
|macro-paths|Directories to where your macros live|
|snapshot-paths|Directories to where your snapshots live|
|docs-paths|Directories to where your docs blocks live|
|vars|Project variables you want to use for data compilation|

---
## **`dbt_project.yml` example**
``` yaml
name: string

config-version: 2
version: version

profile: profilename

model-paths: [directorypath]
seed-paths: [directorypath]
test-paths: [directorypath]
analysis-paths: [directorypath]
macro-paths: [directorypath]
snapshot-paths: [directorypath]
docs-paths: [directorypath]
asset-paths: [directorypath]

target-path: directorypath
log-path: directorypath
packages-install-path: directorypath

clean-targets: [directorypath]

query-comment: string

require-dbt-version: version-range | [version-range]

quoting:
  database: true | false
  schema: true | false
  identifier: true | false

models:
  <model-configs>

seeds:
  <seed-configs>

snapshots:
  <snapshot-configs>

sources:
  <source-configs>
  
tests:
  <test-configs>

vars:
  <variables>

on-run-start: sql-statement | [sql-statement]
on-run-end: sql-statement | [sql-statement]

dispatch:
  - macro_namespace: packagename
    search_order: [packagename]
```
---


# duckdb
  - https://duckdb.org/
  > DuckDB is an embedded database, similar to SQLite, but designed for OLAP-style analytics. It is crazy fast and allows you to read and write data stored in CSV and Parquet files directly, without requiring you to load them into the database first.



# dbt-duckdb
## isntall
```bash
# create conda env
conda create -n dbt python=3.9 -y
conda activate dbt
pip install dbt-duckdb

# duckcli : https://github.com/dbcli/duckcli
pip install -U duckcli
```

## dbt-duckdb example
  - https://github.com/dbt-labs/jaffle_shop_duckdb
  - `jaffle_shop` is a fictional ecommerce store
```
jaffle_shop_duckdb
└── models
    └── staging
        ├── schema.yml
        ├── stg_customers.sql
        ├── stg_orders.sql
        ├── stg_payments.sql
    ├── customers.sql
    ├── docs.md
    ├── orders.sql
    ├── overview.md
    ├── schema.yml
└── seeds
    ├── raw_customers.csv
    ├── raw_orders.csv
    ├── raw_payments.csv
└── dbt_project.yml
```

`dbt_project.yml`
```yml
name: 'jaffle_shop'

config-version: 2
version: '0.1'

profile: 'jaffle_shop'

model-paths: ["models"]
seed-paths: ["seeds"]
test-paths: ["tests"]
analysis-paths: ["analysis"]
macro-paths: ["macros"]

target-path: "target"
clean-targets:
    - "target"
    - "dbt_modules"
    - "logs"

require-dbt-version: [">=1.0.0", "<2.0.0"]

seeds: 
  +docs:
    node_color: '#cd7f32'

models:
  jaffle_shop:
    materialized: table
    staging:
      materialized: view
      +docs:
        node_color: 'silver'
    +docs:
      node_color: 'gold'
```

## Running example project
### Mach Speed: No explanation needed

> Run `dbt` as fast as possible in a single copy and paste motion!

> 기본적으로 `dbt build`를 통해 전체를 end-to-end로 실행할 수 있음.

```bash
git clone https://github.com/dbt-labs/jaffle_shop_duckdb.git
cd jaffle_shop_duckdb
conda activate dbt
python3 -m pip install --upgrade pip
pip install -r requirements.txt
dbt build
```
<details>
<summary>

### output

</summary>

```bash
 /mnt/c/U/s/z/w/d/jaffle_shop_duckdb | on duckdb ?1  dbt build                        ok | dbt py | system node | at 14:42:35
05:45:06  Running with dbt=1.3.1
05:45:06  Found 5 models, 20 tests, 0 snapshots, 0 analyses, 292 macros, 0 operations, 3 seed files, 0 sources, 0 exposures, 0 metrics
05:45:06
05:45:06  Concurrency: 24 threads (target='dev')
05:45:06
05:45:06  1 of 28 START seed file main.raw_customers ..................................... [RUN]
05:45:06  2 of 28 START seed file main.raw_orders ........................................ [RUN]
05:45:06  3 of 28 START seed file main.raw_payments ...................................... [RUN]
05:45:07  1 of 28 OK loaded seed file main.raw_customers ................................. [INSERT 100 in 0.16s]
05:45:07  2 of 28 OK loaded seed file main.raw_orders .................................... [INSERT 99 in 0.16s]
05:45:07  3 of 28 OK loaded seed file main.raw_payments .................................. [INSERT 113 in 0.18s]
05:45:07  4 of 28 START sql view model main.stg_customers ................................ [RUN]
05:45:07  5 of 28 START sql view model main.stg_orders ................................... [RUN]
05:45:07  6 of 28 START sql view model main.stg_payments ................................. [RUN]
05:45:07  6 of 28 OK created sql view model main.stg_payments ............................ [OK in 0.17s]
05:45:07  4 of 28 OK created sql view model main.stg_customers ........................... [OK in 0.18s]
05:45:07  5 of 28 OK created sql view model main.stg_orders .............................. [OK in 0.19s]
05:45:07  7 of 28 START test accepted_values_stg_payments_payment_method__credit_card__coupon__bank_transfer__gift_card  [RUN]
05:45:07  8 of 28 START test not_null_stg_payments_payment_id ............................ [RUN]
05:45:07  9 of 28 START test unique_stg_payments_payment_id .............................. [RUN]
05:45:07  10 of 28 START test not_null_stg_customers_customer_id ......................... [RUN]
05:45:07  11 of 28 START test unique_stg_customers_customer_id ........................... [RUN]
05:45:07  12 of 28 START test accepted_values_stg_orders_status__placed__shipped__completed__return_pending__returned  [RUN]
05:45:07  13 of 28 START test not_null_stg_orders_order_id ............................... [RUN]
05:45:07  14 of 28 START test unique_stg_orders_order_id ................................. [RUN]
05:45:07  9 of 28 PASS unique_stg_payments_payment_id .................................... [PASS in 0.25s]
05:45:07  7 of 28 PASS accepted_values_stg_payments_payment_method__credit_card__coupon__bank_transfer__gift_card  [PASS in 0.25s]
05:45:07  8 of 28 PASS not_null_stg_payments_payment_id .................................. [PASS in 0.26s]
05:45:07  14 of 28 PASS unique_stg_orders_order_id ....................................... [PASS in 0.25s]
05:45:07  13 of 28 PASS not_null_stg_orders_order_id ..................................... [PASS in 0.25s]
05:45:07  12 of 28 PASS accepted_values_stg_orders_status__placed__shipped__completed__return_pending__returned  [PASS in 0.25s]
05:45:07  10 of 28 PASS not_null_stg_customers_customer_id ............................... [PASS in 0.26s]
05:45:07  11 of 28 PASS unique_stg_customers_customer_id ................................. [PASS in 0.26s]
05:45:07  15 of 28 START sql table model main.orders ..................................... [RUN]
05:45:07  16 of 28 START sql table model main.customers .................................. [RUN]
05:45:07  15 of 28 OK created sql table model main.orders ................................ [OK in 0.15s]
05:45:07  16 of 28 OK created sql table model main.customers ............................. [OK in 0.32s]
05:45:07  17 of 28 START test accepted_values_orders_status__placed__shipped__completed__return_pending__returned  [RUN]
05:45:07  18 of 28 START test not_null_orders_amount ..................................... [RUN]
05:45:07  19 of 28 START test not_null_orders_bank_transfer_amount ....................... [RUN]
05:45:07  20 of 28 START test not_null_orders_coupon_amount .............................. [RUN]
05:45:07  21 of 28 START test not_null_orders_credit_card_amount ......................... [RUN]
05:45:07  22 of 28 START test not_null_orders_customer_id ................................ [RUN]
05:45:07  23 of 28 START test not_null_orders_gift_card_amount ........................... [RUN]
05:45:07  24 of 28 START test not_null_orders_order_id ................................... [RUN]
05:45:07  25 of 28 START test unique_orders_order_id ..................................... [RUN]
05:45:07  26 of 28 START test not_null_customers_customer_id ............................. [RUN]
05:45:07  27 of 28 START test relationships_orders_customer_id__customer_id__ref_customers_  [RUN]
05:45:07  28 of 28 START test unique_customers_customer_id ............................... [RUN]
05:45:08  17 of 28 PASS accepted_values_orders_status__placed__shipped__completed__return_pending__returned  [PASS in 0.28s]
05:45:08  18 of 28 PASS not_null_orders_amount ........................................... [PASS in 0.28s]
05:45:08  21 of 28 PASS not_null_orders_credit_card_amount ............................... [PASS in 0.28s]
05:45:08  20 of 28 PASS not_null_orders_coupon_amount .................................... [PASS in 0.29s]
05:45:08  19 of 28 PASS not_null_orders_bank_transfer_amount ............................. [PASS in 0.29s]
05:45:08  24 of 28 PASS not_null_orders_order_id ......................................... [PASS in 0.28s]
05:45:08  22 of 28 PASS not_null_orders_customer_id ...................................... [PASS in 0.29s]
05:45:08  23 of 28 PASS not_null_orders_gift_card_amount ................................. [PASS in 0.29s]
05:45:08  26 of 28 PASS not_null_customers_customer_id ................................... [PASS in 0.28s]
05:45:08  25 of 28 PASS unique_orders_order_id ........................................... [PASS in 0.29s]
05:45:08  27 of 28 PASS relationships_orders_customer_id__customer_id__ref_customers_ .... [PASS in 0.29s]
05:45:08  28 of 28 PASS unique_customers_customer_id ..................................... [PASS in 0.30s]
05:45:08
05:45:08  Finished running 3 seeds, 3 view models, 20 tests, 2 table models in 0 hours 0 minutes and 1.53 seconds (1.53s).
05:45:08
05:45:08  Completed successfully
05:45:08
05:45:08  Done. PASS=28 WARN=0 ERROR=0 SKIP=0 TOTAL=28
```

</details>

> 데이터베이스 파일의 경로는 profiles.ymldbt 구성 파일에서 설정.
```yaml
  outputs:
    dev:
      type: duckdb
      path: 'jaffle_shop.duckdb'
```
```
 /mnt/c/U/s/z/w/d/jaffle_shop_duckdb | on duckdb ?1  ll *.duckdb                      ok | dbt py | system node | at 14:46:47
-rw-r--r-- 1 sc 1000 2.3M Nov 22 14:45 jaffle_shop.duckdb
```


### **duckdb 확인**
output 로그 내용을 살펴보면 아래 순서로 진행되는 것을 알 수 있다.
 - `seeds/` data 로드 -> `models/staging` view 생성 -> `models/staging` 테스트 -> `models/` 테이블 생성 -> 테스트
 - 생성된 `jaffle_shop.duckdb`에서도 `seed`(raw_*), `stg`(stg_*), `model`(customers, orders) 테이블이 생성되어 있음을 확인할 수 있다.

```
 /mnt/c/U/s/z/w/d/jaffle_shop_duckdb | on duckdb ?1  duckcli jaffle_shop.duckdb       ok | dbt py | system node | at 14:46:53

Version: 0.2.1
GitHub: https://github.com/dbcli/duckcli
jaffle_shop.duckdb> \dt
+---------------+
| table_name    |
+---------------+
| customers     |
| orders        |
| raw_payments  |
| raw_orders    |
| raw_customers |
| stg_payments  |
| stg_customers |
| stg_orders    |
+---------------+
Time: 0.008s
jaffle_shop.duckdb>
```

> 데모 프로젝트에서 data source는 csv seed data (`./seeds`) 이지만 이것이 dbt로 작업하는 일반적인 방법은 아니며, 일반적으로 데이터가 이미 데이터베이스에 있을 것이라고 함.


### **dbt build**
  - https://docs.getdbt.com/reference/commands/build
  - 앞에서 dbt build 명령어로 end-to-end 실행이 된다고 했는데 dbt build에 대해 좀 더 알아보자.

```
The dbt build command will:

run models
test tests
snapshot snapshots
seed seeds
```

#### **dbt seed**
> The dbt seed command will load csv files located in the seed-paths directory of your dbt project into your data warehouse.

seed-paths is defined in `./dbt_project.yml`:
```yaml
seed-paths: ["seeds"]
```

```bash
 /mnt/c/U/s/z/w/d/jaffle_shop_duckdb | on duckdb ?1  ls -l seeds                      ok | dbt py | system node | at 15:26:13
total 12
-rw-r--r-- 1 sc 1000 1302 Nov 22 09:56 raw_customers.csv
-rw-r--r-- 1 sc 1000 2723 Nov 22 09:56 raw_orders.csv
-rw-r--r-- 1 sc 1000 2560 Nov 22 09:56 raw_payments.csv
```

`기존 .duckdb 삭제 후 빈 .duckdb 파일 생성`
```bash
rm jaffle_shop.duckdb
duckcli jaffle_shop.duckdb
# ctrl + d로 빠져나오기
```

`dbt seed --models raw_customers`
```
 /mnt/c/U/s/z/w/d/jaffle_shop_duckdb | on duckdb ?1  dbt seed --models raw_customers  ok | dbt py | system node | at 15:26:22
06:36:31  Running with dbt=1.3.1
06:36:31  Found 5 models, 20 tests, 0 snapshots, 0 analyses, 292 macros, 0 operations, 3 seed files, 0 sources, 0 exposures, 0 metrics
06:36:31
06:36:31  Concurrency: 24 threads (target='dev')
06:36:32
06:36:32  1 of 1 START seed file main.raw_customers ...................................... [RUN]
06:36:32  1 of 1 OK loaded seed file main.raw_customers .................................. [INSERT 100 in 0.13s]
06:36:32
06:36:32  Finished running 1 seed in 0 hours 0 minutes and 0.33 seconds (0.33s).
06:36:32
06:36:32  Completed successfully
06:36:32
06:36:32  Done. PASS=1 WARN=0 ERROR=0 SKIP=0 TOTAL=1
```

`duckcli로 확인`
- raw_customers 테이블 생성
```
 /mnt/c/U/s/z/w/d/jaffle_shop_duckdb | on duckdb ?1  duckcli jaffle_shop.duckdb
Version: 0.2.1
GitHub: https://github.com/dbcli/duckcli
jaffle_shop.duckdb> \dt
+---------------+
| table_name    |
+---------------+
| raw_customers |
+---------------+
Time: 0.008s
jaffle_shop.duckdb> select count(*) from raw_customers;
+--------------+
| count_star() |
+--------------+
| 100          |
+--------------+
1 row in set
Time: 0.004s
jaffle_shop.duckdb> .schema raw_customers
+--------------------------------------------------------------------------------+
| sql                                                                            |
+--------------------------------------------------------------------------------+
| CREATE TABLE raw_customers(id INTEGER, first_name VARCHAR, last_name VARCHAR); |
+--------------------------------------------------------------------------------+
Time: 0.006s
```

`raw_customers` 테이블 업데이트 후 다시 `dbt seed` 실행
```
jaffle_shop.duckdb> update raw_customers set last_name='pikachu';
+-------+
| Count |
+-------+
| 100   |
+-------+
1 row in set
Time: 0.006s
jaffle_shop.duckdb> select last_name,count(*) from raw_customers group by last_name;
+-----------+--------------+
| last_name | count_star() |
+-----------+--------------+
| pikachu   | 100          |
+-----------+--------------+
1 row in set
Time: 0.005s
```

시드 데이터를 재설정하고 변경 사항을 수정함을 확인 가능
```
dbt seed --models raw_customers
duckcli jaffle_shop.duckdb
jaffle_shop.duckdb> select last_name,count(*) from raw_customers group by last_name;
+-----------+--------------+
| last_name | count_star() |
+-----------+--------------+
| P.        | 7            |
| M.        | 8            |
| C.        | 7            |
...
```

#### **dbt run**
> dbt run executes compiled sql model files against the current target database

#### **dbt test**


